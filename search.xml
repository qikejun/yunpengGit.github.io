<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise 到 Generator 再到 Async / Await]]></title>
    <url>%2F2019%2F08%2F23%2Fpromise%2F</url>
    <content type="text"><![CDATA[1. js 异步处理的异步最早的解决方案是回调函数，如事件的回调，setInterval/setTimeout 中的回调。但是回到函数有一个很常见的问题，回调地狱。 为了解决回调地狱问题，社区提出了 promise 解决方案，es6 将其写进了语言标准，promise 解决了回调地狱问题，但是 promise 也存在一些问题，如错误能被 try catch，而且使用 promise 的链式调用，其实没有从根本上解决回调地狱的问题，只是换了一种写法。 es6 中引入了 Generator 函数，Generator 是一种异步编程解决方案，Generator 函数是协程在 es6 的实现，最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语句注明，但是 Genrator 使用起来比较复杂。 es7 又提出了新的一步解决方案：async / await, async 是 Generator 的函数语法糖，async/await 使得异步代码看起来像同步，异步编程发展的目标就是让异步逻辑的代码看起来像同步一样。 回调函数： callback 123//node读取文件fs.readFile(xx,'utf-8',function(err. data) &#123;&#125;) 回调函数的使用场景（包括但不限于）： 事件回调 Node API setTimeout 、setInterval 中的回调函数 异步回调嵌套会导致代码难以维护，并且不方便统一处理错误，不能 try catch 和回调地狱（如读取 A 文本的类容，再根据 A 文本内容读取 B 文本，再根据 B 文本内容读取 C..) 回调地狱： 1234567fs.readFile(A, 'utf-8', function() &#123; fs.readFile(B, 'utf-8', function() &#123; fs.readFile(C, 'utf-8', function() &#123; //... &#125;) &#125;)&#125;) 2. Promisepromise 主要解决回调地狱的问题，promise 最早由社区提出和实现，es6 将其写进语言标准，统一用法，原生提供 Promise 对象； Promise 解决回调地狱问题： 12345678910111213141516171819function read(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url, 'utf-8', (err, data) =&gt; &#123; if (err) reject(data) resolve(data) &#125;) &#125;)&#125;read(A) .then(data =&gt; &#123; return read(B) &#125;) .then(data =&gt; &#123; return read(C) &#125;) .catch(reason =&gt; &#123; console.log(reason) &#125;) 思考： 在 Promise 之前，你是如何处理异步并发问题的，假设有这样一个需求：读取三个文件内容，都读取成功后，输出最终的结果。有了 Promise 之后，又如何处理呢？示例 Promise 有哪些优缺点？ 优点 promise 对象，可以将 异步操作 以 同步操作的流程 表达出来，避免层层嵌套 缺点 promise 一旦新建，就会立即执行，无法取消 如果不设置回掉函数，promise 内部抛出的错误就不会反应到外部 处于 pending 状态时，是不能知道目前进展到哪个阶段的 ( 刚开始？，即将结束？) 123456789101112131415161718192021const P1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(new Error('fail')) console.log('3s') // console.log语句仍然会执行，并且在reject()异步函数 前执行 &#125;, 3000)&#125;)const P2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(P1) console.log('1s') &#125;, 1000)&#125;)P2.then(res =&gt; console.log(res)) // 并没有执行 .catch(error2 =&gt; console.log(error2))P1.then(res =&gt; console.log(res)) // 并没有执行 .catch(error1 =&gt; console.log(error1))// 注意： P2.then(res =&gt; console.log(....))并没有执行，因为P2的状态变成了P1的状态，是rejected// P2.then(res =&gt; console.log(res,'fulfilled'), res =&gt; console.log(res,'rejected'))// 实际执行的是上面的 第二个回调函数// error1 与 error2 分别是 P1 和 P2 的错误处理回调 ，当前代码P1，P2都是 reject，所以两个回调都行，error1 先于 error2执行 解析： Promise 实例具体的状态由创建时执行的回调函数决定 resolve(则执行.then()) or reject(则执行.catch())； 调用 resolve 或 reject 以后，Promise 的使命就完成，后继操作在 then 或 carch 方法中，而不应该在 resolve 或 reject 的后写处理逻辑。（可以加 return 来处理不执行后面逻辑，最好直接不写） P1 是 promise 的一个实例对象，3s 后状态变为 rejected P2 是 promise 的一个实例对象，状态在 1s 后改变，但是 P2 的 resolve 方法 return 的是 P1 导致 P2 的状态由 P1 决定，即 P1 为 rejected，则 P2 也是 reject 所以只会执行 .catch() P2 等待 P1 的状态改变为 fulfilled 或者 rejected，P1 状态改变后，执行 P1 的回调 ，根据状态为 rejected 执行 .catch 回调 P2 执行回调，状态为 rejected 执行.catch ( 所以 1s 的时候，P2 还没有状态，所以无法执行回调 )(3s 后，P2 有状态，是 rejected，即是 P1 的状态 执行 .catch 回调函数) .then() promise 实例有.then 方法，定义在原型对象 Promise.prototype 上的 then() 方法的作用是为 promise 实例添加状态改变后的回调函数 then() 方法参数是两个回调函数，第一个是 resolved 状态回调函数，第二个是 rejected 状态回调函数 ( 第二个参数可选，一般都不用，而用 catch()方法捕获错误 ，有第二个回调则 catch 回调不会执行) then() 方法返回的是新的 promise 实例，因此可以采用链式写法 then()方法的链式调用 12345678910111213141516171819202122let i = 0setInterval(() =&gt; &#123; console.log(`经过了$&#123;++i&#125;s`)&#125;, 1000)const link = new Promise((resolve, reject) =&gt; &#123; return setTimeout(() =&gt; &#123; resolve('2s的promise的fulfilled状态返回值') &#125;, 2000)&#125;)link .then(res =&gt; console.log(res)) .then(res =&gt; console.log(res)) //then默认有两个参数(回调函数)，根据上一个函数返回的状态resolve，reject，来决定执行第几个，如果没有具体的返回值，则默认返回undefined，默认执行第一个函数，res参数为undefined .then(res =&gt; &#123; res =&gt; console.log(res) //res为undefined return new Promise((resolve, reject) =&gt; &#123; return setTimeout(() =&gt; &#123; return reject('3s的promise的rejected状态返回值') &#125;, 1000) &#125;) &#125;) .then(res =&gt; console.log(res, 'reject'), res =&gt; console.log(res, 'reject')) .catch() Promise.prototype.catch() 是 .then(null, rejection) 的别名，指定发生错误时的回调函数,代替 then 第二个回调函数，then()有第二参数函数不执行 catch(); promise 实例对象的状态变为 rejected，就会触发 catch() 方法的回调函数 then 方法指定的函数在运行时抛出错误，会被 catch() 方法捕获 promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止( 也就是说错误总是会被下一个 catch 语句捕获 ) 一般不要在.then()中捕获 rejected 状态的捕获 一般在 promise 对象实例后跟 catch()方法，这样可以处理 promise 内部发生法的错误，catch() 方法返回的还是 promise 对象，因此后面还可以接着调用 then() 方法 catch() 方法中还能再抛错误，如果 catch()方法抛出错误，后面没有 catch()方法，错误就不会被捕获，也不会传递到外层。如果catch()方法抛出错误后，后面有then()方法，会照常执行，后面有catch()方法，错误还会被再一次捕获 finally() promise.prototype.finally()方法用于指定不管 promise 对象最后的状态如何，都会执行的操作 finally() 参数回调函数，不接受任何参数。( 这就意味着，无法知道前面 pormise 实例对象最后的状态是 fulfilled 还是 rejected，finally()函数中的操作与状态无关，不依赖 promise 对象执行的结果 ) finally 总是会返回之前的值 Promise.all() Promise.all() 方法用于将多个 promise 实例，包装成一个新的 promise 实例 promise.all() 方法的参数可以不是数组，但是必须具有 iterator 接口，且返回的每个成员都是 promise 实例 ( 具有 iterator 接口，就是可遍历的数据结构，可以被 for…of 遍历 ) 注意：如果作为参数的 promise 实例 ( 即Promise.all()实例子是rejected状态 )自己定义了 catch()方法，就不会触发 Promise.all()实例的 catch() 方法 12345678910111213const p = Promise.all( [p1, p2, p3] );上面代码中，promise.all()方法，接受一个数组作为参数，p1, p2, p3都是promise实例promise.all() 方法的参数可以不是数组，但是必须具有 iterator 接口p的状态由 p1, p2, p3决定，分两种情况(1) 只有p1,p2,p3的状态都变为 fulfilled， p的状态才会变为 fulfilled 此时，p1,p2,p3的返回值组成一个数组，传递给p的回调函数(2) 只要p1,p2,p3中有一个被 rejected，p的状态就变成rejected 此时，第一个被rejected的实例的返回值，会传给p的回调函数 情况示例 1： 12345678910111213let a = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)let b = new Promise((resolve, reject) =&gt; &#123; resolve(2)&#125;)let c = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)const p = Promise.all([a, b, c]) // a,b,c都是promise实例对象p.then(res =&gt; console.log(res)) // 输出 [1, 2, 3] 示例 2： 12345678910111213let a = new Promise((resolve, reject) =&gt; &#123; reject(1)&#125;)let b = new Promise((resolve,reject) =&gt; &#123; resolve(2)&#125;)let c = new Promise((resolve,reject) =&gt; &#123; resolve(3)&#125;)const p = Promise.all([a,b,c]) // a,b,c都是promise实例对象p.then(res =&gt; console.log(res)) //不执行 .catch(err =&gt; console.log(err)) // 输出 1 特殊示例：(注意最后的返回值,返回值都是一个 promise 对象) 1234567891011121314151617181920212223const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result)//执行返回'hello'.catch(e =&gt; e);//没有执行//最后返回 p1 = 'hello'(promise对象).then(result =&gt; console.log(result)) //执行返回 undefined.catch(e =&gt; console.log(e)); //没有执行const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('错了');//Promise 回调函数调用抛错&#125;).then(result =&gt; result)//没有执行.catch(e =&gt; e); //执行返回错误信息//最后返回值 P2 = Error:错了(promise对象).then(result =&gt; console.log(result))//没有执行.catch(e =&gt; console.log(e));//执行返回 undefinedPromise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// ["hello", Error: 错了] Promise.race() 对比 Promise.all() Promise.race() 方法的作用同样是将多个 promise 对象实例包装成新的 promise 实例 race 是赛跑，率先的意思 p1, p2, p3 中实例对象的状态有一个率先改变， p 的状态就会跟这改变 ( 无论是变为 fulfilled 状态，还是变为 rejected 状态 )，p 的回调函数的参数，是最先改变状态的那个 promise 实例的返回值 传入的参数是不可迭代的，将会抛出错误。 传的参数数组是空，返回的 promise 将永远等待。 实现一个 Promise.race 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Promise.race = function(promiseObj) &#123; //promises 必须是一个可遍历的数据结构，否则抛错 return new Promise((resolve, reject) =&gt; &#123; //判断当前的promiseObj是否可迭代 if (typeof promiseObj[Symbol.iterator] !== 'function') &#123; Promise.reject('args is not iteratable!') &#125; if (promiseObj.length === 0) &#123; return &#125; else &#123; for (let i = 0, l = promiseObj.length; i &lt; l; i++) &#123; Promise.resolve(promiseObj[i]).then( data =&gt; &#123; resolve(data) return &#125;, err =&gt; &#123; reject(err) return &#125; ) &#125; &#125; &#125;)&#125;//测试//一直在等待态Promise.race([]).then( data =&gt; &#123; console.log('success ', data) &#125;, err =&gt; &#123; console.log('err ', err) &#125;)//抛错Promise.race().then( data =&gt; &#123; console.log('success ', data) &#125;, err =&gt; &#123; console.log('err ', err) &#125;)Promise.race([ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 1000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2) &#125;, 200) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(3) &#125;, 300) &#125;)]).then( data =&gt; &#123; console.log(data) &#125;, err =&gt; &#123; console.log(err) &#125;) Promise.resolve() promise.resolve()可以将对象转换为 promise 对象 promise.resolve(‘foo’) 等价于 new Promise(resolve =&gt; resolve(&#39;foo&#39;)) Promise.resolve() 参数示例： 参数为 promise 实例对象，Promise.resolve()方法将原封不动的( 返回这个实例对象 ) 123456const foo = new Promise((resolve, reject) =&gt; &#123; return resolve('promise实例对象')&#125;)const p = Promise.resolve(foo)console.log(p)// 输出： Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: "foo是一个promise实例对象"&#125; 参数为 thenable 对象，Promise.resolve()方法会将这个对象转化为 promise 对象，然后立刻执行 thenable 对象的 then 方法 123456789什么是 thenable 对象 ？let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;Promise.resolve(thenable) // 参数是thenable对象，立刻执行thenable对象的then方法 .then(res =&gt; console.log(res)) // thenable对象的的状态是fulfilled，输出其返回值 参数不是 thenable 对象，或者根本不是一个对象，参数是一个原始类型的值( 数字，字符串，布尔值 )，或者是一个不具有 then 方法的对象，则 Promise.resolve()方法返回一个新的 promise 对象，状态是 fulfilled 12345const str = 'abc'const foo = Promise.resolve(str)// 参数是原始类型的值，Promise.resolve()方法会返回一个promise对象，状态是resolvedfoo.then(res =&gt; console.log(res)) // 所以该回调会执行 不带参数,直接返回一个 promise 对象，状态是 resolved; Promise.reject()方法 Promise.reject()方法返回一个 promise 实例对象，状态是 rejected 和 Promise.resolve()类似，只是 Promise.rejected()方法的状态一定是 rejected 123456789101112const p = Promise.reject('出错了')p.then(null, function(s) &#123; console.log(s)&#125;)// 出错了// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function(s) &#123; console.log(s)&#125;)// 出错了 3. GeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案，整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。 Generator 函数一般配合 yield 或 Promise 使用。Generator 函数返回的是迭代器。 123456789101112131415161718function* gen() &#123; let a = yield 11 console.log(a) let b = yield 22 console.log(b) let c = yield 33 console.log(c) let d = yield 44 console.log(d)&#125;let t = gen()//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值//next 调用后返回一个对象&#123;value: yield 后面的值, done: false&#125;t.next(1) //第一次调用next函数时，传递的参数无效 返回&#123;value:11,done:false&#125;t.next(2) //a输出2; 返回&#123;value:22,done:false&#125;t.next(3) //b输出3;t.next(4) //c输出4;t.next(5) //d输出5; 返回&#123;value: undefined, done: true&#125; async async关键字，定义的函数是异步函数，返回promise对象 await 操作符用于等待一个 Promise 对象, 只能在异步函数 async function 内部使用. 123456789const fun1 = () =&gt; console.log('叭叭叭1') const fun2 = () =&gt; console.log('叭叭叭2') const fun = async () =&gt; &#123; // async关键字，定义的函数是异步函数，返回promise对象 await fun1() &#125; fun().then(fun2()) console.log('叭叭叭')]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
