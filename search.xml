<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里云ecs服务器nginx搭建</title>
    <url>/2019/10/24/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E6%9C%8D%E5%8A%A1%E5%99%A8nginx%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="服务器部署文档-windows"><a href="#服务器部署文档-windows" class="headerlink" title="服务器部署文档 - windows"></a>服务器部署文档 - windows</h1><h2 id="测试服务器"><a href="#测试服务器" class="headerlink" title="测试服务器"></a>测试服务器</h2><p>centOS6.9</p>
<p>内网ip <code>10.88.80.142</code></p>
<p>公网ip <code>39.97.236.118</code></p>
<h3 id="服务器操作"><a href="#服务器操作" class="headerlink" title="服务器操作"></a>服务器操作</h3><ol>
<li><p>使用工具</p>
<p>Xshell 6 连接服务器，Xftp 6 本地文件上传服务器（快捷入口（标准按钮，和 Xshell 图标一起的绿色图标，点击打开 Xftp），<strong>上传文件注意当前服务器文件夹所在目录</strong>）</p>
</li>
<li><p>连接服务器</p>
</li>
<li><p>yum安装必要的包（阿里云服务器内置 yum ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf pcre-devel make automake</span><br><span class="line">yum -y install wget httpd-tools vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#有些包服务器已经内置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看nginx 安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql nginx</span><br><span class="line"></span><br><span class="line">#文件目录</span><br><span class="line"> /etc/logrotate.d/nginx</span><br><span class="line"> /etc/nginx</span><br><span class="line"> /etc/nginx/conf.d</span><br><span class="line"> /etc/nginx/conf.d/default.conf</span><br><span class="line"> /etc/nginx/fastcgi_params</span><br><span class="line"> /etc/nginx/koi-utf</span><br><span class="line"> /etc/nginx/koi-win</span><br><span class="line"> /etc/nginx/mime.types</span><br><span class="line"> /etc/nginx/modules</span><br><span class="line"> /etc/nginx/nginx.conf</span><br><span class="line"> /etc/nginx/scgi_params</span><br><span class="line"> /etc/nginx/uwsgi_params</span><br><span class="line"> /etc/nginx/win-utf</span><br><span class="line"> /etc/sysconfig/nginx</span><br><span class="line"> /etc/sysconfig/nginx-debug</span><br><span class="line"> /usr/lib/systemd/system/nginx-debug.service</span><br><span class="line"> /usr/lib/systemd/system/nginx.service</span><br><span class="line"> /usr/lib64/nginx</span><br><span class="line"> /usr/lib64/nginx/modules</span><br><span class="line"> /usr/libexec/initscripts/legacy-actions/nginx</span><br><span class="line"> /usr/libexec/initscripts/legacy-actions/nginx/check-reload</span><br><span class="line"> /usr/libexec/initscripts/legacy-actions/nginx/upgrade</span><br><span class="line"> /usr/sbin/nginx</span><br><span class="line"> /usr/sbin/nginx-debug</span><br><span class="line"> /usr/share/doc/nginx-1.16.1</span><br><span class="line"> /usr/share/doc/nginx-1.16.1/COPYRIGHT</span><br><span class="line"> /usr/share/man/man8/nginx.8.gz</span><br><span class="line"> /usr/share/nginx</span><br><span class="line"> /usr/share/nginx/html</span><br><span class="line"> /usr/share/nginx/html/50x.html</span><br><span class="line"> /usr/share/nginx/html/index.html</span><br><span class="line"> /var/cache/nginx</span><br><span class="line"> /var/log/nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用的基本命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nginx 命令</span></span><br><span class="line">nginx <span class="comment">#启动服务器</span></span><br><span class="line">nginx -s quit <span class="comment">#停止服务器</span></span><br><span class="line">nginx -s reload <span class="comment">#重启服务器</span></span><br><span class="line">ps -ef | grep nginx <span class="comment">#查询启动的nginx进程</span></span><br><span class="line"><span class="built_in">kill</span> -QUIT 进程id <span class="comment">#从容停止进程</span></span><br><span class="line"><span class="built_in">kill</span> -TERM 进程id <span class="comment">#快速停止进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程id <span class="comment">#强制停止进程</span></span><br><span class="line">fuser -n tcp 端口号 <span class="comment">#查看端口占用</span></span><br><span class="line"><span class="built_in">kill</span> -9 端口号 <span class="comment">#结束端口占用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件查看编辑</span></span><br><span class="line"><span class="built_in">cd</span> /  <span class="comment">#直接到顶层 / 目录下</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment">#返回上一层目录</span></span><br><span class="line"><span class="built_in">cd</span> 文件夹名称 <span class="comment">#进入到文件夹名目录下</span></span><br><span class="line">ls   <span class="comment">#查看当前目录下的所有文件，文件夹</span></span><br><span class="line">cat 文件名 <span class="comment">#查看文件内容</span></span><br><span class="line"></span><br><span class="line">vim 文件名 <span class="comment">#编辑文件</span></span><br><span class="line"><span class="comment">#进入编辑模式</span></span><br><span class="line"><span class="comment">#按 i 开始编辑，上下左右减调整指针位置，</span></span><br><span class="line"><span class="comment">#按 esc 退出编辑模式</span></span><br><span class="line"><span class="comment">#输入 :q 不保存退出 :wq 保存退出</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="反向代理-配置"><a href="#反向代理-配置" class="headerlink" title="反向代理 配置"></a>反向代理 配置</h3><p><span style="color:red">注：在文件 etc/nginx/conf.d/default.conf 中配置是无效的</span></p>
<p>我刚开始配置在 default.conf 中时，控制台报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">502 Bad Gateway</span><br></pre></td></tr></table></figure>

<p>查询 var/log/nginx  cat error.log可能会遇到以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSL_do_handshake() failed (SSL: error:14077102:SSL routines:SSL23_GET_SERVER_HELLO:unsupported protocol) while SSL handshaking to upstream</span><br></pre></td></tr></table></figure>

<p> <strong><span style="color:skyblue;">配置文件  etc/nginx/nginx.conf</span></strong></p>
<p> 将当前的请求<a href="https://ceshi.com/api/getData(服务器域名(ceshi.com)转发到" target="_blank" rel="noopener">https://ceshi.com/api/getData(服务器域名(ceshi.com)转发到</a> <a href="https://www.baidu.com/getData" target="_blank" rel="noopener">https://www.baidu.com/getData</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">    	listen       80;</span><br><span class="line">        <span class="comment">#server_name  localhost;</span></span><br><span class="line">        server_name  ceshi.com;</span><br><span class="line"></span><br><span class="line">        location ^~/api/ &#123;</span><br><span class="line"> 	        proxy_pass https://www.baidu.com/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式转换的秘密</title>
    <url>/2019/10/22/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    <content><![CDATA[<h2 id="读书：你不知道的JavaScript（中卷）"><a href="#读书：你不知道的JavaScript（中卷）" class="headerlink" title="读书：你不知道的JavaScript（中卷）"></a>读书：你不知道的JavaScript（中卷）</h2><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>‘+’ 作为数字加法操作是可互换的，即2 + 3 等同于3 + 2。作为字符串拼接操作则不行，但对空字符串”” 来说，a + “” 和”” + a 结果一样，如果没有空字符串，互换位置，拼接后的结果是不一样的。</p>
<p>a + “”（隐式）和前面的 String(a)（显式）之间有一个细微的差别需要注意。</p>
<p><strong><span style="color:skyblue">根据 ToPrimitive 抽象操作规则，a + “” 会对a 调用valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。而String(a) 则是直接调用ToString()。</span></strong></p>
<p>它们最后返回的都是字符串，但如果a 是对象而非数字结果可能会不一样！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;,</span><br><span class="line">toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a + <span class="string">""</span>; <span class="comment">// "42"</span></span><br><span class="line"><span class="built_in">String</span>( a ); <span class="comment">// "4"</span></span><br></pre></td></tr></table></figure>

<p><strong>在定制 valueOf () 和 toString () 方法时需要特别小心，因为这会影响强制类型转换的结果。</strong></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>event-loop</title>
    <url>/2019/09/02/event-loop/</url>
    <content><![CDATA[<h4 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="headerlink" title="事件循环(event-loop)"></a>事件循环(event-loop)</h4><blockquote>
<p>主线程从任务队列不断的循环读取执行事件，这个机制叫称为事件循环。</p>
</blockquote>
<ol>
<li>宏任务（macrotask ）: script（一般执行逻辑，方法调用，console）, setTimeout, setInterval, I/O, UI rendering</li>
<li>微任务（microtask ）: process.nextTick（Nodejs）, Promises,</li>
</ol>
<p>JS 引擎会将所有的任务按照类别分到这两队列中，</p>
<p>主线程不断从任务队列按顺序读取执行任务，首先看主线程代码队列有没有需要执行的代码，有则执行代码，没有则检查<strong>微任务</strong>队列是否为空（函数执行栈为空），不为空则会执行完所有<strong>微任务</strong>，再进行下一个循环去任务队列读取下一个任务执行。`</p>
<blockquote>
<p>示例解析</p>
</blockquote>
<ol>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//执行后 回调一个宏事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内层宏事件3'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'外层宏事件1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外层宏事件2'</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'微事件1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'微事件2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    外层宏事件1</span></span><br><span class="line"><span class="comment">    外层宏事件2</span></span><br><span class="line"><span class="comment">    微事件1</span></span><br><span class="line"><span class="comment">    微事件2</span></span><br><span class="line"><span class="comment">    Promise &#123;&lt;resolved&gt;: undefined&#125;    //new Promise() 返回一个promise对象</span></span><br><span class="line"><span class="comment">    内层宏事件3</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.首先js进入第一个宏任务进入主线程, 遇到 setTimeout  分发到宏任务Event Queue中</span></span><br><span class="line"><span class="comment">2.遇到 console.log() 直接执行，输出 "外层宏事件1"</span></span><br><span class="line"><span class="comment">3.遇到 Promise， new Promise 执行，执行参数箭头函数输出 外层宏事件2"</span></span><br><span class="line"><span class="comment">4.接着执行then，任务发到 微任务 Event Queue</span></span><br><span class="line"><span class="comment">5.第一轮宏任务执行结束，查看执行微任务队列</span></span><br><span class="line"><span class="comment">6.输出"微事件1" "微事件1"，第一轮微任务执行结束</span></span><br><span class="line"><span class="comment">7.第二轮宏任务开始执行 ，输出 "内层宏事件3"</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async1 start'</span> )</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async1 end'</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async2'</span> )</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'script start'</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    async1 start</span></span><br><span class="line"><span class="comment">    async2</span></span><br><span class="line"><span class="comment">    script start</span></span><br><span class="line"><span class="comment">    async1 end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.js进入主线程进入第一个宏任务，遇到async1，async2，函数声明</span></span><br><span class="line"><span class="comment">2.遇到 async1() 调用执行 输出 "async1 start"</span></span><br><span class="line"><span class="comment">3.遇到 await async2()，await 就立刻让出线程,阻塞后面的代码 等待 async2执行结束，输出 "async2"</span></span><br><span class="line"><span class="comment">4.await会阻塞后面的代码,先执行async外面的同步代码, 输出 'script start'</span></span><br><span class="line"><span class="comment">如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</span></span><br><span class="line"><span class="comment">5.同步代码执行完毕后,在回到async内部，执行输出 "asnyc1 end"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async1 start'</span> )</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async1 end'</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'async2'</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'script start'</span> )</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'setTimeout'</span> )</span><br><span class="line">&#125;, <span class="number">0</span> )</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span> (<span class="params"> resolve </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'promise1'</span> )</span><br><span class="line">    resolve();</span><br><span class="line">&#125; ).then( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'promise2'</span> )</span><br><span class="line">&#125; )</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'script end'</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*结果分析</span></span><br><span class="line"><span class="comment">1.await async2()调用输出 "async2",之后，</span></span><br><span class="line"><span class="comment">2.继续执行最外层宏任务队列，接着执行最外层微任务队列，</span></span><br><span class="line"><span class="comment">3.然后在执行await async2()之后的逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout1"</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">    111</span></span><br><span class="line"><span class="comment">    setTimeout1</span></span><br><span class="line"><span class="comment">    222</span></span><br><span class="line"><span class="comment">    setTimeout2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout---0'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout---200'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inner-setTimeout---0'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise5'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise3</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout---0</span></span><br><span class="line"><span class="comment">setTimeout---200</span></span><br><span class="line"><span class="comment">promise5</span></span><br><span class="line"><span class="comment">inner-setTimeout---0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果分析</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.js进入主线程进入第一个宏任务，遇到console 输出 "script start"</span></span><br><span class="line"><span class="comment">2.遇到第一个 setTimeout 放入宏任务 task queue，等待执行</span></span><br><span class="line"><span class="comment">3.遇到第二个 setTimeout 放入宏任务 task queue，等待执行</span></span><br><span class="line"><span class="comment">4.遇到第一个 Promise.resolve().then 放入微任务 task queue，等待执行</span></span><br><span class="line"><span class="comment">5.遇到第二个 Promise.resolve().then 放入微任务 task queue，等待执行</span></span><br><span class="line"><span class="comment">6.遇到 conmsole 输出 "script end",第一个宏任务执行结束</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7.检查执行微任务 4,5 执行 输出 "promise1 promise3 promise2" 第一个微任务结束</span></span><br><span class="line"><span class="comment">	a.由于Promise.resolve().then()返回的还是一个promise对象，所以第二个then也是一个微任务，在调用第二个微任务是将其添加到微任务 task queue 中等待执行</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">8.宏任务执行 第一个 setTimeout 输出 "setTimeout---0"</span></span><br><span class="line"><span class="comment">9.第二个 setTimeout 等待 200 毫秒 执行，</span></span><br><span class="line"><span class="comment">10.遇到  console.log 输出 "setTimeout---200"</span></span><br><span class="line"><span class="comment">11.遇到 setTiemeout 放入宏任务 task queue，等待执行</span></span><br><span class="line"><span class="comment">12.遇到 Promise.resolve().then 放入微任务 task queue，等待执行</span></span><br><span class="line"><span class="comment">13.第二个 setTimeout 内部第一个宏任务 执行结束 查看微任务并执行</span></span><br><span class="line"><span class="comment">14.微任务 输出 "promise5"，微任务执行结束 查看宏任务并执行</span></span><br><span class="line"><span class="comment">15.宏任务 输出 "inner-setTimeout---0",所有任务执行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js类型转换</title>
    <url>/2019/08/29/js-type-conversion/</url>
    <content><![CDATA[<h4 id="js类型转换分为-强制类型转换-和隐式类型转换。"><a href="#js类型转换分为-强制类型转换-和隐式类型转换。" class="headerlink" title="js类型转换分为 强制类型转换 和隐式类型转换。"></a>js类型转换分为 强制类型转换 和隐式类型转换。</h4><ol>
<li>Number()、parseInt()、parseFloat()、toString()、String()、Boolean() 强制类型转换</li>
<li>逻辑运算符(&amp;&amp;、||、!)、运算符(+、-、*、/)、关系操作符(&gt;、&lt;、&lt;=、&gt;=)、相等运算符(==)或if/while 的条件、可能会进行隐式转换。</li>
</ol>
<p><strong>类型强制转换</strong></p>
<blockquote>
<p>1.Number() 将任意类型的参数转换为数值类型<strong>简写 前面加 +</strong></p>
</blockquote>
<p>规则：</p>
<ol>
<li><p>布尔值，true和false转换为1和0</p>
</li>
<li><p>数字，返回自身</p>
</li>
<li><p>null，返回 0</p>
</li>
<li><p>undefined，返回 NaN</p>
</li>
<li><p>字符串，规则：</p>
<ul>
<li>字符串只包含数字(或者是 0X / 0x 开头的十六进制的数字字符串，允许包含正负号)，转换为十进制数</li>
<li>字符串中包含有效的浮点格式，将其转换为浮点数值</li>
<li>空字符串，将其转换为0</li>
<li>不是以上格式的字符串，均返回 <code>NaN</code></li>
</ul>
</li>
<li><p>Symbol，抛出错误</p>
</li>
<li><p>对象，则调用对象的 <code>valueOf()</code> 方法，然后依据前面的规则转换返回的值。如果转换的// <code>NaN</code> ，则调用对象的 <code>toString()</code> 方法，再次依照前面的规则转换返回的字符串值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'0X12'</span>) <span class="comment">//18</span></span><br><span class="line">+<span class="string">'0X12'</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">-0x12</span>)<span class="comment">//-18</span></span><br><span class="line">+<span class="number">-0x12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-0x12'</span>)<span class="comment">//NaN</span></span><br><span class="line">+<span class="string">'-0x12'</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0123'</span>); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">''</span>]); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>([]); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1a'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="built_in">Symbol</span>());<span class="comment">// Cannot convert a Symbol value to a number at Number</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>2.parseInt (param, radix)</p>
</blockquote>
<p>parseInt ( param, radix)将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数(为空时默认为10)。</p>
<p>第一个参数是字符串类型:</p>
<ol>
<li><p>忽略字符串前面的空格，直至找到第一个非空字符，如果是空字符串，返回 NaN</p>
</li>
<li><p>第一个字符不是数字或数字符号（ 0X / 0x 开头的十六进制的数字）或者正负号，返回 NaN</p>
</li>
<li><p>第一个字符是数字/正负号，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">' 123s1'</span>) <span class="comment">//123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">' 0X12'</span>) <span class="comment">//18</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">' -s'</span>) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第一个参数传入的 Number 类型:</p>
<ol>
<li><p>数字如果是 0 开头，则将其当作八进制来解析(如果是一个八进制数)；如果以 0x 开头，则将其当作十六进制来解析</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">012</span>) <span class="comment">//10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x12</span>) <span class="comment">//18</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第一个参数是 null 或者是 undefined，或者是一个对象类型：</p>
<ol>
<li><p>返回NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">undefined</span>) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123;&#125;) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([]) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="string">''</span>]) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第一个参数是数组：</p>
<ol>
<li><p>取数组的第一个元素，按照上面规则解析</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>([<span class="string">''</span>]) =&gt; <span class="built_in">parseInt</span>(<span class="string">''</span>) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第一个参数是Symbol类型：</p>
<ol>
<li><p>报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Symbol</span>()) <span class="comment">//Cannot convert a Symbol value to a string at parseInt</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>parseFloat()</p>
</blockquote>
<p>规则和<code>parseInt</code>基本相同，接受一个Number类型或字符串，是字符串中，只有第一个小数点是有效的。</p>
<blockquote>
<p>toString()      </p>
</blockquote>
<p>规则：</p>
<ol>
<li><p>Number类型，输出数字字符串</p>
</li>
<li><p>null 或者是 undefined，抛错</p>
</li>
<li><p>数组，那么将数组展开输出。空数组，返回<code>&#39;&#39;</code></p>
</li>
<li><p>对象，返回 <code>[object Object]</code></p>
</li>
<li><p>Date, 返回日期的文字表示法</p>
</li>
<li><p>函数，输出对应的字符串</p>
</li>
<li><p>Symbol，输出Symbol字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123.</span>toString() <span class="comment">//'123'</span></span><br><span class="line"><span class="number">123</span>+<span class="string">''</span> </span><br><span class="line"><span class="literal">null</span>.toString() <span class="comment">//Cannot read property 'toString' of null</span></span><br><span class="line"><span class="literal">null</span>+<span class="string">''</span> <span class="comment">//'null'</span></span><br><span class="line"><span class="literal">undefined</span>.toString() <span class="comment">//Cannot read property 'toString' of undefined</span></span><br><span class="line"><span class="literal">undefined</span>+<span class="string">''</span><span class="comment">//'undefined'</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString() <span class="comment">//'1,2,3'</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]+<span class="string">''</span></span><br><span class="line">[].toString() <span class="comment">//''</span></span><br><span class="line">[]+<span class="string">''</span></span><br><span class="line"></span><br><span class="line">&#123;&#125;.toString() <span class="comment">//Uncaught SyntaxError: Unexpected token .</span></span><br><span class="line">&#123;&#125;+<span class="string">''</span> <span class="comment">//0</span></span><br><span class="line"><span class="keyword">let</span> obj=&#123;&#125; obj.toString() <span class="comment">//"[object Object]"</span></span><br><span class="line">obj+<span class="string">''</span> <span class="comment">//"[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(); date.toString() <span class="comment">//"Thu Aug 29 2019 14:37:38 GMT+0800 (中国标准时间)"</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">fn.toString() <span class="comment">//"function ()&#123;&#125;"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="number">123</span>).toString() <span class="comment">//"Symbol(123)"</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="built_in">Symbol</span>(<span class="number">123</span>) str.toString() <span class="comment">//"Symbol(123)"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>String()  *<em>简写方式 拼接 + “” *</em></p>
</blockquote>
<p><code>String()</code> 的转换规则与 <code>toString()</code> 基本一致，最大的一点不同在于 <code>null</code> 和 <code>undefined</code>，使用 String 进行转换，null 和 undefined对应的是字符串 <code>&#39;null&#39;</code> 和 <code>&#39;undefined&#39;</code></p>
<blockquote>
<p>Boolean <strong>简写方式 !!</strong></p>
</blockquote>
<p>除了 undefined、 null、 false、 ‘’、 0(包括 +0，-0)、 NaN 是false，其它都是true.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(expression);     <span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = !!(expression);          <span class="comment">// 推荐</span></span><br><span class="line">!![] <span class="comment">//true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">//true</span></span><br><span class="line">!![<span class="string">''</span>]<span class="comment">//true</span></span><br><span class="line">!!<span class="string">''</span>  <span class="comment">//false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>隐式类型转换</strong></p>
<blockquote>
<p>&amp;&amp; 、|| 、 ! 、 if/while 的条件判断</p>
</blockquote>
<p>将数据转换成 Boolean 类型，转换规则同 Boolean 强制类型转换</p>
<blockquote>
<p>运算符: + - * /</p>
</blockquote>
<p><code>+</code> 号操作符，数字相加，字符串拼接。</p>
<ol>
<li><p><code>+</code> 号两边数字，加法运算，两边字符串，字符串拼接</p>
</li>
<li><p>操作数是对象、数组、数字、布尔值、转换规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;&#125;) <span class="comment">//"[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>([]) <span class="comment">//""</span></span><br><span class="line">[]+<span class="string">''</span>      <span class="comment">//""</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">//"null"</span></span><br><span class="line"><span class="literal">null</span>+<span class="string">''</span>    <span class="comment">//'null'</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">//"undefined"</span></span><br><span class="line"><span class="literal">undefined</span>  <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;,b=[],c=<span class="literal">null</span>,d=<span class="literal">undefined</span>,e=<span class="string">''</span>;</span><br><span class="line">a.toString()  <span class="comment">//"[object Object]"</span></span><br><span class="line">b.toString()  <span class="comment">//""</span></span><br><span class="line">e.toString()  <span class="comment">//""</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>+<span class="number">10</span>); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>+<span class="literal">true</span>); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">//null1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>+&#123;&#125;) <span class="comment">//null[object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>+<span class="number">10</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>+<span class="literal">true</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">//null1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>+&#123;&#125;) <span class="comment">//null[object Object]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将对象，数组数字转换为 字符串拼接</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;+<span class="number">10</span>); <span class="comment">//"[object Object]10"</span></span><br><span class="line"><span class="built_in">console</span>.log([]+<span class="number">10</span>); <span class="comment">//"10"</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;+[<span class="number">1</span>,<span class="number">3</span>]) <span class="comment">//"[object Object]1,3"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>+&#123;&#125;)  <span class="comment">//"false[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>+&#123;&#125;)   <span class="comment">//"true[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>+[<span class="number">1</span>,<span class="number">2</span>])  <span class="comment">//"false1,2"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>+[])  <span class="comment">//"true"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>布尔值和 数字 (将数字转换为数字计算)</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>+<span class="number">10</span>)   <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>+<span class="number">10</span>)   <span class="comment">//11</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>-</code>、<code>*</code>、<code>/</code> 操作符是运算，操作值不是数值，则被隐式调用Number()函数进行转换。如果其中有一个转换为NaN，结果为NaN.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>([]) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">10</span>]) <span class="comment">//10</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>,<span class="number">0</span>]) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关系操作符: ==、&gt;、&lt; 、&lt;=、&gt;=</p>
</blockquote>
<ol>
<li>两个操作值都是数值，则进行数值比较</li>
<li>两个操作值都是字符串，则比较字符串对应的字符编码值</li>
<li>有一方是Symbol类型，抛出错误</li>
<li>除了上述情况之外，都进行Number()进行类型转换，然后再进行比较。</li>
</ol>
<p><strong>注：</strong> NaN 它其他任何类型的值都不相等，包括它自己，同时它与任何类型的值比较都返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &gt; &#123;&#125;);<span class="comment">//返回false.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *&#123;&#125;.valueOf ---&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment"> *&#123;&#125;.toString() ---&gt; '[object Object]' ---&gt; NaN</span></span><br><span class="line"><span class="comment"> *NaN 和 任何类型比大小，都返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相等操作符：<code>==</code></p>
</blockquote>
<ol>
<li><p>类型相同，无需进行类型转换。</p>
</li>
<li><p>其中一个操作值是 null 或者是 undefined，那么另一个操作符必须为 null 或者 undefined 时，才返回 true，否则都返回 false.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中一个是 Symbol 类型，那么返回 false.</p>
</li>
<li><p>两个 一个值是数字，另一个值是字符串，先将字符串转换为数学，然后使用转换后的值进行比较。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>==<span class="string">'01'</span> <span class="comment">//=&gt; 0==0 true</span></span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="number">0</span>==<span class="string">'0'</span> <span class="comment">//=&gt; 0==0  true</span></span><br><span class="line"><span class="number">0</span>==[]  <span class="comment">//=&gt; 0==0  true</span></span><br><span class="line"><span class="string">'0'</span>==[]  <span class="comment">//=&gt; '0'==''  false</span></span><br></pre></td></tr></table></figure>

<p><img src="https://yunpenggit.github.io/code/%E5%9B%BE%E8%A7%A3%E5%89%8D%E7%AB%AF/0-'0'-%5B%5D.jpg" alt="图"></p>
</li>
<li><p><strong>几个特殊的对象：<code>&#39;&#39;，0，&#39;0&#39;，[]，{}</code></strong></p>
<p><strong><span style="color:skyblue"> <code>{}</code> 对象在有操作符中执行时，在 <code>{}</code> 之前有操作符，则当做 <code>{}</code> 空对象处理，如果没有则被当作一个独立的空代码块（不执行任何操作)</span></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...+...加号的运算优先级从左到右</span></span><br><span class="line"><span class="string">''</span>+&#123;&#125;  <span class="comment">//"[object Object]"     ''字符串遇到+执行字符串拼接操作,&#123;&#125;当做一个空对象处理，转为字符串"[object Object]"</span></span><br><span class="line">&#123;&#125;+<span class="string">''</span> <span class="comment">//0  &#123;&#125;之前没有任何操作符，被当作一个独立的空代码块（不执行任何操作),+''空字符串转为数字0</span></span><br><span class="line"></span><br><span class="line">&#123;&#125;+<span class="string">''</span>=== <span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line">&#123;&#125;+<span class="string">''</span>==<span class="string">'0'</span> <span class="comment">//true =&gt; 0 =='0'</span></span><br><span class="line"><span class="string">''</span>+&#123;&#125;==<span class="string">'0'</span> <span class="comment">//false =&gt;</span></span><br><span class="line"><span class="string">'0'</span>==&#123;&#125;+<span class="string">''</span> <span class="comment">//false =&gt; '0'=="[object Object]"+'' &#123;&#125;之前有==操作符，当做空对象处理，+ 执行字符串拼接操作</span></span><br><span class="line"><span class="string">'0'</span>==<span class="string">''</span>+&#123;&#125; <span class="comment">//false =&gt;'0'==''+"[object Object]" &#123;&#125;之前有+操作符，当做空对象处理，+ 执行字符串拼接操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...==... 运算优先级从左到右</span></span><br><span class="line"><span class="number">0</span>==<span class="string">'0'</span> <span class="comment">//true =&gt; 0==0   +'0'=&gt; 0</span></span><br><span class="line"><span class="number">0</span>==[]  <span class="comment">//true 0==0     +[]=&gt; 0</span></span><br><span class="line"><span class="string">'0'</span>==[] <span class="comment">//false '0'=='' []+''=&gt;''</span></span><br><span class="line"></span><br><span class="line">[]+&#123;&#125;   <span class="comment">// "[object Object]"</span></span><br><span class="line">&#123;&#125;+[]   <span class="comment">// 0</span></span><br><span class="line">(&#123;&#125;+[])   <span class="comment">// "[object Object]"</span></span><br><span class="line">+[]     <span class="comment">// 0   ，此处+为正号</span></span><br><span class="line">+&#123;&#125;     <span class="comment">// NaN   ，此处+为正号</span></span><br><span class="line">[].toString()    <span class="comment">// ""</span></span><br><span class="line">(&#123;&#125;).toString() <span class="comment">// "[object Object]"    </span></span><br><span class="line">&#123;&#125;.toString() <span class="comment">//会出错，Uncaught SyntaxError: Unexpected token .</span></span><br><span class="line"><span class="number">0</span>+[]    <span class="comment">// "0"</span></span><br><span class="line"><span class="number">0</span>+&#123;&#125;    <span class="comment">// "0[object Object]"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个操作值是 boolean，那么转换成 number</p>
</li>
<li><p>一个操作值为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断(调用 object 的valueOf() / toString()方法进行转换)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//== 左右的对象转换 </span></span><br><span class="line"><span class="comment">//三目运算符？前面的对象转换为Boolean类型</span></span><br><span class="line"><span class="built_in">console</span>.log(([])?<span class="literal">true</span>:<span class="literal">false</span>); </span><br><span class="line"><span class="built_in">console</span>.log(([]==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>)); </span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;==<span class="literal">false</span>)?<span class="literal">true</span>:<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">下面是题目的类型转换结果：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>([]); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">因此：</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(([])?<span class="literal">true</span>:<span class="literal">false</span>);<span class="comment">// =&gt; console.log((true)?true:false); 三目运算符？前面的表达式需要转换为Boolean类型 !!快捷转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>);<span class="comment">// =&gt; console.log(true?true:false); </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>);<span class="comment">// =&gt; console.log(false?true:false); </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([]==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>); <span class="comment">// =&gt; console.log(0==0?true:false);</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;==<span class="literal">false</span>)?<span class="literal">true</span>:<span class="literal">false</span>); <span class="comment">// =&gt; console.log((NaN==0)?true:false);</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p><strong>对象如何转换成原始数据类型</strong></p>
</blockquote>
<p><strong>如果有 [Symbol.toPrimitive]  接口，那么调用此接口，若返回的不是基础数据类型，抛出错误。如果没有 [Symbol.toPrimitive] 接口，那么先返回 valueOf() 的值，若返回的不是基础类型的值，再返回 toString() 的值，若返回的不是基础类型的值， 则抛出异常。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先调用 valueOf, 后调用 toString</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 valueOf 返回的不是基本数据类型，则会调用 toString， </span></span><br><span class="line"><span class="comment">//如果 toString 返回的也不是基本数据类型，会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">200</span>); <span class="comment">//400</span></span><br></pre></td></tr></table></figure>

<p><strong>a等于什么以下逻辑打印1</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a=?</span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>a为对象，a的取值规则 [对象如何转换成原始数据类型] </p>
<p>取值相关的三个属性方法，Symbol.toPrimitive、valueOf、toString</p>
<ul>
<li><p>Symbol.toPrimitive示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用闭包创建独立作用域的特性，每次返回一个值</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a设定一个属性i返回,每次取值都返回这个改变后的i</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    i:<span class="number">1</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>valueOf、toString 同上</p>
</li>
</ul>
</li>
<li><p>Object.definePropert 获取a属性时，调用get.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> b++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组在类型转换时调用toString()返回一个字符串，该字符串有由数组的每一个值的toString()返回值调用join()连接而成（join默认使用逗号连接）；重写 join 方法，让其依次返回数组元素</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>promise-介绍</title>
    <url>/2019/08/28/promise-info/</url>
    <content><![CDATA[<h3 id="Promise-介绍"><a href="#Promise-介绍" class="headerlink" title="Promise 介绍"></a>Promise 介绍</h3><p>Promise 有哪些优缺点？</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>promise 对象，可以将 <strong>异步操作</strong> 以 <strong>同步操作的流程</strong> 表达出来，避免层层嵌套</p>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>promise 一旦新建，就会立即执行，无法取消</li>
<li>如果不设置回掉函数，promise 内部抛出的错误就不会反应到外部</li>
<li>处于 pending 状态时，是不能知道目前进展到哪个阶段的 ( 刚开始？，即将结束？)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> P1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3s'</span>) <span class="comment">// console.log语句仍然会执行，并且在reject()异步函数 前执行</span></span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> P2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(P1)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1s'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">P2.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 并没有执行</span></span><br><span class="line">  .catch(<span class="function"><span class="params">error2</span> =&gt;</span> <span class="built_in">console</span>.log(error2))</span><br><span class="line">P1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 并没有执行</span></span><br><span class="line">  .catch(<span class="function"><span class="params">error1</span> =&gt;</span> <span class="built_in">console</span>.log(error1))</span><br><span class="line"><span class="comment">// 注意： P2.then(res =&gt; console.log(....))并没有执行，因为P2的状态变成了P1的状态，是rejected</span></span><br><span class="line"><span class="comment">// P2.then(res =&gt; console.log(res,'fulfilled'), res =&gt; console.log(res,'rejected'))</span></span><br><span class="line"><span class="comment">// 实际执行的是上面的 第二个回调函数</span></span><br><span class="line"><span class="comment">// error1 与 error2 分别是 P1 和 P2 的错误处理回调 ，当前代码P1，P2都是 reject，所以两个回调都行，error1 先于 error2执行</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>Promise 实例具体的状态由创建时执行的回调函数决定 resolve(则执行.then()) or reject(则执行.catch())；</p>
<p>调用 resolve 或 reject 以后，Promise 的使命就完成，后继操作在 then 或 carch 方法中，而不应该在 resolve 或 reject 的后写处理逻辑。（可以加 return 来处理不执行后面逻辑，最好直接不写）</p>
<ol>
<li>P1 是 promise 的一个实例对象，3s 后状态变为 rejected</li>
<li>P2 是 promise 的一个实例对象，状态在 1s 后改变，但是 P2 的 resolve 方法 return 的是 P1</li>
<li>导致 P2 的状态由 P1 决定，即 P1 为 rejected，则 P2 也是 reject 所以只会执行 .catch()</li>
<li>P2 等待 P1 的状态改变为 fulfilled 或者 rejected，P1 状态改变后，执行 P1 的回调 ，根据状态为 rejected 执行 .catch 回调</li>
<li>P2 执行回调，状态为 rejected 执行.catch</li>
<li>( 所以 1s 的时候，P2 还没有状态，所以无法执行回调 )(3s 后，P2 有状态，是 rejected，即是 P1 的状态 执行 .catch 回调函数)</li>
</ol>
<blockquote>
<p>.then()</p>
</blockquote>
<p>promise 实例有.then 方法，定义在原型对象 Promise.prototype 上的</p>
<ul>
<li>then() 方法的作用是为 promise 实例添加状态改变后的回调函数</li>
<li>then() 方法参数是两个回调函数，第一个是 resolved 状态回调函数，第二个是 rejected 状态回调函数 ( 第二个参数可选，一般都不用，而用 catch()方法捕获错误 ，有第二个回调则 catch 回调不会执行)</li>
<li><strong>then() 方法返回的是新的 promise 实例，因此可以采用链式写法</strong></li>
</ul>
<blockquote>
<p>then()方法的链式调用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`经过了<span class="subst">$&#123;++i&#125;</span>s`</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> link = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'2s的promise的fulfilled状态返回值'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">link</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">//then默认有两个参数(回调函数)，根据上一个函数返回的状态resolve，reject，来决定执行第几个，如果没有具体的返回值，则默认返回undefined，默认执行第一个函数，res参数为undefined</span></span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(res) <span class="comment">//res为undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="string">'3s的promise的rejected状态返回值'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res, <span class="string">'reject'</span>), res =&gt; <span class="built_in">console</span>.log(res, <span class="string">'reject'</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.catch()</p>
</blockquote>
<p>Promise.prototype.catch() 是 .then(null, rejection) 的别名，指定发生错误时的回调函数,代替 then 第二个回调函数，then()有第二参数函数不执行 catch();</p>
<ul>
<li>promise 实例对象的状态变为 rejected，就会触发 catch() 方法的回调函数</li>
<li>then 方法指定的函数在运行时抛出错误，会被 catch() 方法捕获</li>
<li>promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止( 也就是说错误总是会被下一个 catch 语句捕获 )</li>
<li>一般不要在.then()中捕获 rejected 状态的捕获</li>
<li>一般在 promise 对象实例后跟 catch()方法，这样可以处理 promise 内部发生法的错误，catch() 方法返回的还是 promise 对象，因此后面还可以接着调用 then() 方法</li>
<li>catch() 方法中还能再抛错误，如果 catch()方法抛出错误，后面没有 catch()方法，错误就不会被捕获，也不会传递到外层。<code>如果catch()方法抛出错误后，后面有then()方法，会照常执行，后面有catch()方法，错误还会被再一次捕获</code></li>
</ul>
<blockquote>
<p>finally()</p>
</blockquote>
<p>promise.prototype.finally()方法用于指定不管 promise 对象最后的状态如何，都会执行的操作</p>
<ul>
<li>finally() 参数回调函数，不接受任何参数。( 这就意味着，无法知道前面 pormise 实例对象最后的状态是 fulfilled 还是 rejected，finally()函数中的操作与状态无关，不依赖 promise 对象执行的结果 )</li>
<li>finally 总是会返回之前的值</li>
</ul>
<blockquote>
<p>Promise.all()</p>
</blockquote>
<p>Promise.all() 方法用于将多个 promise 实例，包装成一个新的 promise 实例</p>
<ul>
<li>promise.all() 方法的参数可以不是数组，但是必须具有 iterator 接口，且返回的每个成员都是 promise 实例 ( 具有 iterator 接口，就是可遍历的数据结构，可以被 for…of 遍历 )</li>
<li>注意：如果作为参数的 promise 实例 <code>( 即Promise.all()实例子是rejected状态 )</code>自己定义了 catch()方法，就不会触发 Promise.all()实例的 catch() 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all( [p1, p2, p3] );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面代码中，promise.all()方法，接受一个数组作为参数，p1, p2, p3都是promise实例</span><br><span class="line">promise.all() 方法的参数可以不是数组，但是必须具有 iterator 接口</span><br><span class="line"></span><br><span class="line">p的状态由 p1, p2, p3决定，分两种情况</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 只有p1,p2,p3的状态都变为 fulfilled， p的状态才会变为 fulfilled</span><br><span class="line">    此时，p1,p2,p3的返回值组成一个数组，传递给p的回调函数</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 只要p1,p2,p3中有一个被 rejected，p的状态就变成rejected</span><br><span class="line">    此时，第一个被rejected的实例的返回值，会传给p的回调函数</span><br></pre></td></tr></table></figure>

<p>情况示例 1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([a, b, c]) <span class="comment">// a,b,c都是promise实例对象</span></span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	reject(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">	resolve(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">	resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([a,b,c])     <span class="comment">// a,b,c都是promise实例对象</span></span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))	<span class="comment">//不执行</span></span><br><span class="line"> .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<p>特殊示例：(注意最后的返回值,返回值都是一个 promise 对象)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  	resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)<span class="comment">//执行返回'hello'</span></span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);<span class="comment">//没有执行</span></span><br><span class="line"><span class="comment">//最后返回 p1 = 'hello'(promise对象)</span></span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result)) <span class="comment">//执行返回 undefined</span></span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)); <span class="comment">//没有执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'错了'</span>);<span class="comment">//Promise 回调函数调用抛错</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)<span class="comment">//没有执行</span></span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e); <span class="comment">//执行返回错误信息</span></span><br><span class="line"><span class="comment">//最后返回值 P2 = Error:错了(promise对象)</span></span><br><span class="line"></span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))<span class="comment">//没有执行</span></span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));<span class="comment">//执行返回 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 错了]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.race() 对比 Promise.all()</p>
</blockquote>
<p>Promise.race() 方法的作用同样是将多个 promise 对象实例包装成新的 promise 实例</p>
<ul>
<li><p>race 是赛跑，率先的意思</p>
</li>
<li><p>p1, p2, p3 中实例对象的状态有一个率先改变， p 的状态就会跟这改变 ( 无论是变为 fulfilled 状态，还是变为 rejected 状态 )，p 的回调函数的参数，是最先改变状态的那个 promise 实例的返回值</p>
</li>
<li><p>传入的参数是不可迭代的，将会抛出错误。</p>
</li>
<li><p>传的参数数组是空，返回的 promise 将永远等待。</p>
<p>实现一个 Promise.race</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promiseObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises 必须是一个可遍历的数据结构，否则抛错</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前的promiseObj是否可迭代</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promiseObj[<span class="built_in">Symbol</span>.iterator] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.reject(<span class="string">'args is not iteratable!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (promiseObj.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = promiseObj.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promiseObj[i]).then(</span><br><span class="line">          data =&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一直在等待态</span></span><br><span class="line"><span class="built_in">Promise</span>.race([]).then(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success '</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">//抛错</span></span><br><span class="line"><span class="built_in">Promise</span>.race().then(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success '</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">200</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>Promise.resolve()</p>
</blockquote>
<p>promise.resolve()可以将对象转换为 promise 对象</p>
<ul>
<li>promise.resolve(‘foo’) 等价于 <code>new Promise(resolve =&gt; resolve(&#39;foo&#39;))</code></li>
</ul>
<p>Promise.resolve() 参数示例：</p>
<ol>
<li>参数为 promise 实例对象，Promise.resolve()方法将原封不动的<strong>( 返回这个实例对象 )</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="string">'promise实例对象'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(foo)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// 输出： Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: "foo是一个promise实例对象"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数为 thenable 对象，Promise.resolve()方法会将这个对象转化为 promise 对象，然后立刻执行 thenable 对象的 then 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">什么是 thenable 对象 ？</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.resolve(thenable)   <span class="comment">// 参数是thenable对象，立刻执行thenable对象的then方法</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))  <span class="comment">// thenable对象的的状态是fulfilled，输出其返回值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数不是 thenable 对象，或者根本不是一个对象，参数是一个<strong>原始类型的值</strong>( 数字，字符串，布尔值 )，或者是一个<strong>不具有 then 方法的对象</strong>，则 Promise.resolve()方法返回一个新的 promise 对象，状态是 fulfilled</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Promise</span>.resolve(str)</span><br><span class="line"><span class="comment">// 参数是原始类型的值，Promise.resolve()方法会返回一个promise对象，状态是resolved</span></span><br><span class="line"></span><br><span class="line">foo.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 所以该回调会执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不带参数,直接返回一个 promise 对象，状态是 resolved;</li>
</ul>
<blockquote>
<p>Promise.reject()方法</p>
</blockquote>
<p>Promise.reject()方法返回一个 promise 实例对象，状态是 rejected</p>
<ul>
<li>和 Promise.resolve()类似，只是 Promise.rejected()方法的状态一定是 rejected</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>####</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 到 Generator 再到 Async / Await</title>
    <url>/2019/08/23/promise/</url>
    <content><![CDATA[<h4 id="1-js-异步处理的"><a href="#1-js-异步处理的" class="headerlink" title="1. js 异步处理的"></a>1. js 异步处理的</h4><p>异步最早的解决方案是回调函数，如事件的回调，setInterval/setTimeout 中的回调。但是回到函数有一个很常见的问题，回调地狱。</p>
<p>为了解决回调地狱问题，社区提出了 promise 解决方案，es6 将其写进了语言标准，promise 解决了回调地狱问题，但是 promise 也存在一些问题，如错误能被 try catch，而且使用 promise 的链式调用，其实没有从根本上解决回调地狱的问题，只是换了一种写法。</p>
<p>es6 中引入了 Generator 函数，Generator 是一种异步编程解决方案，Generator 函数是协程在 es6 的实现，最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语句注明，但是 Genrator 使用起来比较复杂。</p>
<p>es7 又提出了新的一步解决方案：async / await, async 是 Generator 的函数语法糖，async/await 使得异步代码看起来像同步，异步编程发展的目标就是让异步逻辑的代码看起来像同步一样。</p>
<blockquote>
<p>回调函数： callback</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node读取文件</span></span><br><span class="line">fs.readFile(xx,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err. data</span>) </span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回调函数的使用场景（包括但不限于）：</p>
<ol>
<li>事件回调</li>
<li>Node API</li>
<li>setTimeout 、setInterval 中的回调函数</li>
</ol>
<p>异步回调嵌套会导致代码难以维护，并且不方便统一处理错误，不能 try catch 和回调地狱（如读取 A 文本的类容，再根据 A 文本内容读取 B 文本，再根据 B 文本内容读取 C..)</p>
<p>回调地狱：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(A, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(B, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(C, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h4><p>promise 主要解决回调地狱的问题，promise 最早由社区提出和实现，es6 将其写进语言标准，统一用法，原生提供 Promise 对象；</p>
<p>Promise 解决回调地狱问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(url, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(data)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(A)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(B)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(C)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：</p>
</blockquote>
<p>在 Promise之前，你是如何处理异步并发问题的，假设有这样一个需求：读取三个文件内容，都读取成功后，输出最终的结果。有了 Promise 之后，又如何处理呢？<a href="https://github.com/yunpengGit/code/blob/master/js-example/promise之前处理异步.js" target="_blank" rel="noopener">示例</a></p>
<h4 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3. Generator"></a>3. Generator</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案，整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。</p>
<p>Generator 函数一般配合 yield 或 Promise 使用。Generator 函数返回的是迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">11</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">22</span></span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">33</span></span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="keyword">let</span> d = <span class="keyword">yield</span> <span class="number">44</span></span><br><span class="line">  <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = gen()</span><br><span class="line"><span class="comment">//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</span></span><br><span class="line"><span class="comment">//next 调用后返回一个对象&#123;value: yield 后面的值, done: false&#125;</span></span><br><span class="line">t.next(<span class="number">1</span>) <span class="comment">//第一次调用next函数时，传递的参数无效 返回&#123;value:11,done:false&#125;</span></span><br><span class="line">t.next(<span class="number">2</span>) <span class="comment">//a输出2; 返回&#123;value:22,done:false&#125;</span></span><br><span class="line">t.next(<span class="number">3</span>) <span class="comment">//b输出3;</span></span><br><span class="line">t.next(<span class="number">4</span>) <span class="comment">//c输出4;</span></span><br><span class="line">t.next(<span class="number">5</span>) <span class="comment">//d输出5; 返回&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Async-Await"><a href="#4-Async-Await" class="headerlink" title="4. Async / Await"></a>4. Async / Await</h4><p>async 关键字，<strong>定义的函数是异步函数，返回 promise 对象</strong></p>
<p>await 操作符用于等待一个 Promise 对象, <strong>只能在异步函数 async function 内部使用</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'叭叭叭1'</span>)</span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'叭叭叭2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fun = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// async关键字，定义的函数是异步函数，返回promise对象</span></span><br><span class="line">  <span class="keyword">await</span> fun1()</span><br><span class="line">&#125;</span><br><span class="line">fun().then(fun2())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'叭叭叭'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="async-await-的实现原理"><a href="#async-await-的实现原理" class="headerlink" title="async/await 的实现原理"></a>async/await 的实现原理</h3></blockquote>
<p>async/await 就是 Generator 的语法糖，就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await。</p>
<ol>
<li>async 函数内置执行器，函数调用之后，会自动执行(Generator 需要手动调用函数 next())，输出最后结果。</li>
<li>更好的语义化，async 和 await，对比星号和 yield。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>
<li>更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值。</li>
<li>返回值是 Promise，<strong><span style="color:purple">async 函数的返回值是 Promise 对象在</span>，Generator 的返回值是 Iterator</strong>，Promise 对象使用起来更加方便。</li>
</ol>
<blockquote>
<p>async 函数的实现原理，将 Generator 函数和自动执行器，包装在函数里<a href="https://github.com/yunpengGit/code/blob/master/js-example/async.js" target="_blank" rel="noopener">示例</a></p>
</blockquote>
<blockquote>
<p>使用 async/await 需要注意什么</p>
</blockquote>
<ol>
<li><p>await 命令后面的Promise对象，运行结果可能是 rejected，此时等同于 async 函数返回的 Promise 对象被reject。因此需要加上错误处理，可以给每个 await 后的 Promise 增加 catch 方法；也可以将 await 的代码放在 <code>try...catch</code> 中。</p>
</li>
<li><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面两种写法都可以同时触发</span></span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">600</span>);</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">600</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">800</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> fn2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">800</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">await</span> fn1;</span><br><span class="line">    <span class="keyword">await</span> fn2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>await命令只能用在async函数之中，如果用在普通函数，会报错。</p>
</li>
<li><p>async 函数可以保留运行堆栈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 函数a内部执行异步任务b()。当b()执行的时候，函数a()不会中断，而是继续执行。</span></span><br><span class="line"><span class="comment">* 等到b()执行结束，可能a()已执行结束，b()所在的上下文环境已经消失了。</span></span><br><span class="line"><span class="comment">* 如果b()或c()报错，错误堆栈将不包括a()。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'b中的输出'</span>)</span><br><span class="line">        setTimeout(<span class="function">(<span class="params">resolve</span>)=&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'b-promise实例'</span>)</span><br><span class="line">        &#125;, <span class="number">200</span>,resolve)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c中的输出'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//异步任务b</span></span><br><span class="line">    b().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(data);</span><br><span class="line">        c()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//同步输出</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a中同步输出'</span>)</span><br><span class="line">    <span class="comment">//没有返回默认返回 undefined;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a执行结束'</span></span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    b中的输出</span></span><br><span class="line"><span class="comment">    a中同步输出</span></span><br><span class="line"><span class="comment">    "a执行结束" a()执行结束的返回</span></span><br><span class="line"><span class="comment">    b-promise实例</span></span><br><span class="line"><span class="comment">    c中的输出</span></span><br><span class="line"><span class="comment">    Uncaught (in promise) Error: 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 改成async函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> b_result=<span class="keyword">await</span> b();</span><br><span class="line">    <span class="built_in">console</span>.log(b_result)</span><br><span class="line">    c();</span><br><span class="line">&#125;;</span><br><span class="line">m();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b中的输出</span></span><br><span class="line"><span class="comment">Promise &#123;&lt;pending&gt;&#125; a()执行结束的返回(async 后的函数执行返回一个promise对象)</span></span><br><span class="line"><span class="comment">b-promise实例</span></span><br><span class="line"><span class="comment">c中的输出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
