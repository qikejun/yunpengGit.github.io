<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[event-loop]]></title>
    <url>%2F2019%2F09%2F02%2Fevent-loop%2F</url>
    <content type="text"><![CDATA[事件循环(event-loop) 主线程从任务队列不断的循环读取执行事件，这个机制叫称为事件循环。 宏任务（macrotask ）: script（一般执行逻辑，方法调用，console）, setTimeout, setInterval, I/O, UI rendering 微任务（microtask ）: process.nextTick（Nodejs）, Promises, JS 引擎会将所有的任务按照类别分到这两队列中， 主线程不断从任务队列按顺序读取执行任务，首先看主线程代码队列有没有需要执行的代码，有则执行代码，没有则检查微任务队列是否为空（函数执行栈为空），不为空则会执行完所有微任务，再进行下一个循环去任务队列读取下一个任务执行。` 示例解析 示例 12345678910111213141516171819202122232425262728293031323334setTimeout(() =&gt; &#123; //执行后 回调一个宏事件 console.log('内层宏事件3')&#125;, 0)console.log('外层宏事件1');new Promise((resolve) =&gt; &#123; console.log('外层宏事件2'); resolve()&#125;).then(() =&gt; &#123; console.log('微事件1');&#125;).then(()=&gt;&#123; console.log('微事件2')&#125;)/*执行结果 外层宏事件1 外层宏事件2 微事件1 微事件2 Promise &#123;&lt;resolved&gt;: undefined&#125; //new Promise() 返回一个promise对象 内层宏事件3*/ /*1.首先js进入第一个宏任务进入主线程, 遇到 setTimeout 分发到宏任务Event Queue中2.遇到 console.log() 直接执行，输出 "外层宏事件1"3.遇到 Promise， new Promise 执行，执行参数箭头函数输出 外层宏事件2"4.接着执行then，任务发到 微任务 Event Queue5.第一轮宏任务执行结束，查看执行微任务队列6.输出"微事件1" "微事件1"，第一轮微任务执行结束7.第二轮宏任务开始执行 ，输出 "内层宏事件3" */ 示例 12345678910111213141516171819202122232425262728async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;async1()console.log( 'script start' )/*执行结果 async1 start async2 script start async1 end*//*解析1.js进入主线程进入第一个宏任务，遇到async1，async2，函数声明2.遇到 async1() 调用执行 输出 "async1 start"3.遇到 await async2()，await 就立刻让出线程,阻塞后面的代码 等待 async2执行结束，输出 "async2"4.await会阻塞后面的代码,先执行async外面的同步代码, 输出 'script start'如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。5.同步代码执行完毕后,在回到async内部，执行输出 "asnyc1 end"*/ 示例 123456789101112131415161718192021222324252627282930313233343536async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;console.log( 'script start' )setTimeout( function () &#123; console.log( 'setTimeout' )&#125;, 0 )async1();new Promise( function ( resolve ) &#123; console.log( 'promise1' ) resolve();&#125; ).then( function () &#123; console.log( 'promise2' )&#125; )console.log( 'script end' )/*输出结果script startasync1 startasync2promise1script endpromise2async1 endsetTimeout*//*结果分析1.await async2()调用输出 "async2",之后，2.继续执行最外层宏任务队列，接着执行最外层微任务队列，3.然后在执行await async2()之后的逻辑*/ 示例 12345678910111213141516171819setTimeout(()=&gt;&#123; console.log("setTimeout1"); Promise.resolve().then(data =&gt; &#123; console.log(222); &#125;);&#125;);setTimeout(()=&gt;&#123; console.log("setTimeout2");&#125;);Promise.resolve().then(data=&gt;&#123; console.log(111);&#125;);/*输出结果 111 setTimeout1 222 setTimeout2*/ 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859console.log('script start');setTimeout(function () &#123; console.log('setTimeout---0');&#125;, 0);setTimeout(function () &#123; console.log('setTimeout---200'); setTimeout(function () &#123; console.log('inner-setTimeout---0'); &#125;); Promise.resolve().then(function () &#123; console.log('promise5'); &#125;);&#125;, 200);Promise.resolve().then(function () &#123; console.log('promise1');&#125;).then(function () &#123; console.log('promise2');&#125;);Promise.resolve().then(function () &#123; console.log('promise3');&#125;);console.log('script end');/*输出结果script startscript endpromise1promise3promise2setTimeout---0setTimeout---200promise5inner-setTimeout---0*//*结果分析1.js进入主线程进入第一个宏任务，遇到console 输出 "script start"2.遇到第一个 setTimeout 放入宏任务 task queue，等待执行3.遇到第二个 setTimeout 放入宏任务 task queue，等待执行4.遇到第一个 Promise.resolve().then 放入微任务 task queue，等待执行5.遇到第二个 Promise.resolve().then 放入微任务 task queue，等待执行6.遇到 conmsole 输出 "script end",第一个宏任务执行结束7.检查执行微任务 4,5 执行 输出 "promise1 promise3 promise2" 第一个微任务结束 a.由于Promise.resolve().then()返回的还是一个promise对象，所以第二个then也是一个微任务，在调用第二个微任务是将其添加到微任务 task queue 中等待执行 8.宏任务执行 第一个 setTimeout 输出 "setTimeout---0"9.第二个 setTimeout 等待 200 毫秒 执行，10.遇到 console.log 输出 "setTimeout---200"11.遇到 setTiemeout 放入宏任务 task queue，等待执行12.遇到 Promise.resolve().then 放入微任务 task queue，等待执行13.第二个 setTimeout 内部第一个宏任务 执行结束 查看微任务并执行14.微任务 输出 "promise5"，微任务执行结束 查看宏任务并执行15.宏任务 输出 "inner-setTimeout---0",所有任务执行结束*/]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js类型转换]]></title>
    <url>%2F2019%2F08%2F29%2Fjs-type-conversion%2F</url>
    <content type="text"><![CDATA[js类型转换分为 强制类型转换 和隐式类型转换。 Number()、parseInt()、parseFloat()、toString()、String()、Boolean() 强制类型转换 逻辑运算符(&amp;&amp;、||、!)、运算符(+、-、*、/)、关系操作符(&gt;、&lt;、&lt;=、&gt;=)、相等运算符(==)或if/while 的条件、可能会进行隐式转换。 类型强制转换 1.Number() 将任意类型的参数转换为数值类型简写 前面加 + 规则： 布尔值，true和false转换为1和0 数字，返回自身 null，返回 0 undefined，返回 NaN 字符串，规则： 字符串只包含数字(或者是 0X / 0x 开头的十六进制的数字字符串，允许包含正负号)，转换为十进制数 字符串中包含有效的浮点格式，将其转换为浮点数值 空字符串，将其转换为0 不是以上格式的字符串，均返回 NaN Symbol，抛出错误 对象，则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的规则转换返回的字符串值 123456789101112131415Number('0X12') //18+'0X12'Number(-0x12)//-18+-0x12Number('-0x12')//NaN+'-0x12'Number('0123'); //123Number(''); //0Number(['']); //0Number([]); //0Number(null); //0Number(undefined)//NaNNumber(&#123;&#125;); //NaNNumber('1a'); //NaNNumber(Symbol());// Cannot convert a Symbol value to a number at Number 2.parseInt (param, radix) parseInt ( param, radix)将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数(为空时默认为10)。 第一个参数是字符串类型: 忽略字符串前面的空格，直至找到第一个非空字符，如果是空字符串，返回 NaN 第一个字符不是数字或数字符号（ 0X / 0x 开头的十六进制的数字）或者正负号，返回 NaN 第一个字符是数字/正负号，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止 1234parseInt('') //NaNparseInt(' 123s1') //123parseInt(' 0X12') //18parseInt(' -s') //NaN 第一个参数传入的 Number 类型: 数字如果是 0 开头，则将其当作八进制来解析(如果是一个八进制数)；如果以 0x 开头，则将其当作十六进制来解析 12parseInt(012) //10parseInt(0x12) //18 第一个参数是 null 或者是 undefined，或者是一个对象类型： 返回NaN 12345parseInt(null) //NaNparseInt(undefined) //NaNparseInt(&#123;&#125;) //NaNparseInt([]) //NaNparseInt(['']) //NaN 第一个参数是数组： 取数组的第一个元素，按照上面规则解析 1parseInt(['']) =&gt; parseInt('') //NaN 第一个参数是Symbol类型： 报错 1parseInt(Symbol()) //Cannot convert a Symbol value to a string at parseInt parseFloat() 规则和parseInt基本相同，接受一个Number类型或字符串，是字符串中，只有第一个小数点是有效的。 toString() 规则： Number类型，输出数字字符串 null 或者是 undefined，抛错 数组，那么将数组展开输出。空数组，返回&#39;&#39; 对象，返回 [object Object] Date, 返回日期的文字表示法 函数，输出对应的字符串 Symbol，输出Symbol字符串 123456789101112131415161718192021123.toString() //'123'123+'' null.toString() //Cannot read property 'toString' of nullnull+'' //'null'undefined.toString() //Cannot read property 'toString' of undefinedundefined+''//'undefined'[1,2,3].toString() //'1,2,3'[1,2,3]+''[].toString() //''[]+''&#123;&#125;.toString() //Uncaught SyntaxError: Unexpected token .&#123;&#125;+'' //0let obj=&#123;&#125; obj.toString() //"[object Object]"obj+'' //"[object Object]"let date = new Date(); date.toString() //"Thu Aug 29 2019 14:37:38 GMT+0800 (中国标准时间)"var fn=function ()&#123;&#125; fn.toString() //"function ()&#123;&#125;"Symbol(123).toString() //"Symbol(123)"var str=Symbol(123) str.toString() //"Symbol(123)" String() *简写方式 拼接 + “” * String() 的转换规则与 toString() 基本一致，最大的一点不同在于 null 和 undefined，使用 String 进行转换，null 和 undefined对应的是字符串 &#39;null&#39; 和 &#39;undefined&#39; Boolean 简写方式 !! 除了 undefined、 null、 false、 ‘’、 0(包括 +0，-0)、 NaN 是false，其它都是true. 12345678910var x = Boolean(expression); // 推荐var x = !!(expression); // 推荐!![] //true!!&#123;&#125; //true!!['']//true!!'' //false!!null //false!!undefined //false!!NaN //false!!0 //false 隐式类型转换 &amp;&amp; 、|| 、 ! 、 if/while 的条件判断 将数据转换成 Boolean 类型，转换规则同 Boolean 强制类型转换 运算符: + - * / + 号操作符，数字相加，字符串拼接。 + 号两边数字，加法运算，两边字符串，字符串拼接 操作数是对象、数组、数字、布尔值、转换规则： 12345678910111213141516171819202122String(&#123;&#125;) //"[object Object]"&#123;&#125;+'' //0String([]) //""[]+'' //""String(null) //"null"null+'' //'null'String(undefined) //"undefined"undefined //'undefined'var a=&#123;&#125;,b=[],c=null,d=undefined,e='';a.toString() //"[object Object]"b.toString() //""e.toString() //""console.log(null+10); //10console.log(null+true); //1console.log(null+[1,2,3]) //null1,2,3console.log(null+&#123;&#125;) //null[object Object]console.log(undefined+10); //NaNconsole.log(undefined+true); //NaNconsole.log(undefined+[1,2,3]) //null1,2,3console.log(undefined+&#123;&#125;) //null[object Object] 将对象，数组数字转换为 字符串拼接） 1234567console.log(&#123;&#125;+10); //"[object Object]10"console.log([]+10); //"10"console.log(&#123;&#125;+[1,3]) //"[object Object]1,3"console.log(false+&#123;&#125;) //"false[object Object]"console.log(true+&#123;&#125;) //"true[object Object]"console.log(false+[1,2]) //"false1,2"console.log(true+[]) //"true" 布尔值和 数字 (将数字转换为数字计算) 12console.log(false+10) //10console.log(false+10) //11 -、*、/ 操作符是运算，操作值不是数值，则被隐式调用Number()函数进行转换。如果其中有一个转换为NaN，结果为NaN. 123456Number(&#123;&#125;) //NaNNumber([]) //0Number([10]) //10Number([1,0]) //NaNNumber(null); //0Number(undefined)//NaN 关系操作符: ==、&gt;、&lt; 、&lt;=、&gt;= 两个操作值都是数值，则进行数值比较 两个操作值都是字符串，则比较字符串对应的字符编码值 有一方是Symbol类型，抛出错误 除了上述情况之外，都进行Number()进行类型转换，然后再进行比较。 注： NaN 它其他任何类型的值都不相等，包括它自己，同时它与任何类型的值比较都返回false。 123456console.log(1 &gt; &#123;&#125;);//返回false./** *&#123;&#125;.valueOf ---&gt; &#123;&#125; *&#123;&#125;.toString() ---&gt; '[object Object]' ---&gt; NaN *NaN 和 任何类型比大小，都返回 false */ 相等操作符：== 类型相同，无需进行类型转换。 其中一个操作值是 null 或者是 undefined，那么另一个操作符必须为 null 或者 undefined 时，才返回 true，否则都返回 false. 1null==undefined //true 其中一个是 Symbol 类型，那么返回 false. 两个操作值是否为 string 和 number，将字符串转换为 number 一个操作值是 boolean，那么转换成 number 一个操作值为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断(调用 object 的valueOf() / toString()方法进行转换) 对象如何转换成原始数据类型 如果有 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基础数据类型，抛出错误。如果没有 [Symbol.toPrimitive] 接口，那么先返回 valueOf() 的值，若返回的不是基础类型的值，再返回 toString() 的值，若返回的不是基础类型的值， 则抛出异常。 123456789101112131415//先调用 valueOf, 后调用 toStringlet obj = &#123; [Symbol.toPrimitive]() &#123; return 200; &#125;, valueOf() &#123; return 300; &#125;, toString() &#123; return 'Hello'; &#125;&#125;//如果 valueOf 返回的不是基本数据类型，则会调用 toString， //如果 toString 返回的也不是基本数据类型，会抛出错误console.log(obj + 200); //400 a等于什么以下逻辑打印1 1234// a=?if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; a为对象，a的取值规则 [对象如何转换成原始数据类型] 取值相关的三个属性方法，Symbol.toPrimitive、valueOf、toString Symbol.toPrimitive示例 1234567891011121314151617181920212223//利用闭包创建独立作用域的特性，每次返回一个值let a = &#123; [Symbol.toPrimitive]: (function() &#123; let i = 1; return function() &#123; return i++; &#125; &#125;)()&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125;//a设定一个属性i返回,每次取值都返回这个改变后的ilet a = &#123; i:1, [Symbol.toPrimitive]: function() &#123; return this.i++; &#125;&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; valueOf、toString 同上 Object.definePropert 获取a属性时，调用get. 123456789let b=1;Object.defineProperty(window, 'a', &#123; get: function() &#123; return b++; &#125;&#125;);if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; 数组 12345var a = [1,2,3];a.join = a.shift;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; 数组在类型转换时调用toString()返回一个字符串，该字符串有由数组的每一个值的toString()返回值调用join()连接而成（join默认使用逗号连接）；重写 join 方法，让其依次返回数组元素]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise-介绍]]></title>
    <url>%2F2019%2F08%2F28%2Fpromise-info%2F</url>
    <content type="text"><![CDATA[Promise 介绍Promise 有哪些优缺点？ 优点 promise 对象，可以将 异步操作 以 同步操作的流程 表达出来，避免层层嵌套 缺点 promise 一旦新建，就会立即执行，无法取消 如果不设置回掉函数，promise 内部抛出的错误就不会反应到外部 处于 pending 状态时，是不能知道目前进展到哪个阶段的 ( 刚开始？，即将结束？) 123456789101112131415161718192021const P1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(new Error('fail')) console.log('3s') // console.log语句仍然会执行，并且在reject()异步函数 前执行 &#125;, 3000)&#125;)const P2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(P1) console.log('1s') &#125;, 1000)&#125;)P2.then(res =&gt; console.log(res)) // 并没有执行 .catch(error2 =&gt; console.log(error2))P1.then(res =&gt; console.log(res)) // 并没有执行 .catch(error1 =&gt; console.log(error1))// 注意： P2.then(res =&gt; console.log(....))并没有执行，因为P2的状态变成了P1的状态，是rejected// P2.then(res =&gt; console.log(res,'fulfilled'), res =&gt; console.log(res,'rejected'))// 实际执行的是上面的 第二个回调函数// error1 与 error2 分别是 P1 和 P2 的错误处理回调 ，当前代码P1，P2都是 reject，所以两个回调都行，error1 先于 error2执行 解析： Promise 实例具体的状态由创建时执行的回调函数决定 resolve(则执行.then()) or reject(则执行.catch())； 调用 resolve 或 reject 以后，Promise 的使命就完成，后继操作在 then 或 carch 方法中，而不应该在 resolve 或 reject 的后写处理逻辑。（可以加 return 来处理不执行后面逻辑，最好直接不写） P1 是 promise 的一个实例对象，3s 后状态变为 rejected P2 是 promise 的一个实例对象，状态在 1s 后改变，但是 P2 的 resolve 方法 return 的是 P1 导致 P2 的状态由 P1 决定，即 P1 为 rejected，则 P2 也是 reject 所以只会执行 .catch() P2 等待 P1 的状态改变为 fulfilled 或者 rejected，P1 状态改变后，执行 P1 的回调 ，根据状态为 rejected 执行 .catch 回调 P2 执行回调，状态为 rejected 执行.catch ( 所以 1s 的时候，P2 还没有状态，所以无法执行回调 )(3s 后，P2 有状态，是 rejected，即是 P1 的状态 执行 .catch 回调函数) .then() promise 实例有.then 方法，定义在原型对象 Promise.prototype 上的 then() 方法的作用是为 promise 实例添加状态改变后的回调函数 then() 方法参数是两个回调函数，第一个是 resolved 状态回调函数，第二个是 rejected 状态回调函数 ( 第二个参数可选，一般都不用，而用 catch()方法捕获错误 ，有第二个回调则 catch 回调不会执行) then() 方法返回的是新的 promise 实例，因此可以采用链式写法 then()方法的链式调用 12345678910111213141516171819202122let i = 0setInterval(() =&gt; &#123; console.log(`经过了$&#123;++i&#125;s`)&#125;, 1000)const link = new Promise((resolve, reject) =&gt; &#123; return setTimeout(() =&gt; &#123; resolve('2s的promise的fulfilled状态返回值') &#125;, 2000)&#125;)link .then(res =&gt; console.log(res)) .then(res =&gt; console.log(res)) //then默认有两个参数(回调函数)，根据上一个函数返回的状态resolve，reject，来决定执行第几个，如果没有具体的返回值，则默认返回undefined，默认执行第一个函数，res参数为undefined .then(res =&gt; &#123; res =&gt; console.log(res) //res为undefined return new Promise((resolve, reject) =&gt; &#123; return setTimeout(() =&gt; &#123; return reject('3s的promise的rejected状态返回值') &#125;, 1000) &#125;) &#125;) .then(res =&gt; console.log(res, 'reject'), res =&gt; console.log(res, 'reject')) .catch() Promise.prototype.catch() 是 .then(null, rejection) 的别名，指定发生错误时的回调函数,代替 then 第二个回调函数，then()有第二参数函数不执行 catch(); promise 实例对象的状态变为 rejected，就会触发 catch() 方法的回调函数 then 方法指定的函数在运行时抛出错误，会被 catch() 方法捕获 promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止( 也就是说错误总是会被下一个 catch 语句捕获 ) 一般不要在.then()中捕获 rejected 状态的捕获 一般在 promise 对象实例后跟 catch()方法，这样可以处理 promise 内部发生法的错误，catch() 方法返回的还是 promise 对象，因此后面还可以接着调用 then() 方法 catch() 方法中还能再抛错误，如果 catch()方法抛出错误，后面没有 catch()方法，错误就不会被捕获，也不会传递到外层。如果catch()方法抛出错误后，后面有then()方法，会照常执行，后面有catch()方法，错误还会被再一次捕获 finally() promise.prototype.finally()方法用于指定不管 promise 对象最后的状态如何，都会执行的操作 finally() 参数回调函数，不接受任何参数。( 这就意味着，无法知道前面 pormise 实例对象最后的状态是 fulfilled 还是 rejected，finally()函数中的操作与状态无关，不依赖 promise 对象执行的结果 ) finally 总是会返回之前的值 Promise.all() Promise.all() 方法用于将多个 promise 实例，包装成一个新的 promise 实例 promise.all() 方法的参数可以不是数组，但是必须具有 iterator 接口，且返回的每个成员都是 promise 实例 ( 具有 iterator 接口，就是可遍历的数据结构，可以被 for…of 遍历 ) 注意：如果作为参数的 promise 实例 ( 即Promise.all()实例子是rejected状态 )自己定义了 catch()方法，就不会触发 Promise.all()实例的 catch() 方法 12345678910111213const p = Promise.all( [p1, p2, p3] );上面代码中，promise.all()方法，接受一个数组作为参数，p1, p2, p3都是promise实例promise.all() 方法的参数可以不是数组，但是必须具有 iterator 接口p的状态由 p1, p2, p3决定，分两种情况(1) 只有p1,p2,p3的状态都变为 fulfilled， p的状态才会变为 fulfilled 此时，p1,p2,p3的返回值组成一个数组，传递给p的回调函数(2) 只要p1,p2,p3中有一个被 rejected，p的状态就变成rejected 此时，第一个被rejected的实例的返回值，会传给p的回调函数 情况示例 1： 12345678910111213let a = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)let b = new Promise((resolve, reject) =&gt; &#123; resolve(2)&#125;)let c = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)const p = Promise.all([a, b, c]) // a,b,c都是promise实例对象p.then(res =&gt; console.log(res)) // 输出 [1, 2, 3] 示例 2： 12345678910111213let a = new Promise((resolve, reject) =&gt; &#123; reject(1)&#125;)let b = new Promise((resolve,reject) =&gt; &#123; resolve(2)&#125;)let c = new Promise((resolve,reject) =&gt; &#123; resolve(3)&#125;)const p = Promise.all([a,b,c]) // a,b,c都是promise实例对象p.then(res =&gt; console.log(res)) //不执行 .catch(err =&gt; console.log(err)) // 输出 1 特殊示例：(注意最后的返回值,返回值都是一个 promise 对象) 1234567891011121314151617181920212223const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result)//执行返回'hello'.catch(e =&gt; e);//没有执行//最后返回 p1 = 'hello'(promise对象).then(result =&gt; console.log(result)) //执行返回 undefined.catch(e =&gt; console.log(e)); //没有执行const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('错了');//Promise 回调函数调用抛错&#125;).then(result =&gt; result)//没有执行.catch(e =&gt; e); //执行返回错误信息//最后返回值 P2 = Error:错了(promise对象).then(result =&gt; console.log(result))//没有执行.catch(e =&gt; console.log(e));//执行返回 undefinedPromise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// ["hello", Error: 错了] Promise.race() 对比 Promise.all() Promise.race() 方法的作用同样是将多个 promise 对象实例包装成新的 promise 实例 race 是赛跑，率先的意思 p1, p2, p3 中实例对象的状态有一个率先改变， p 的状态就会跟这改变 ( 无论是变为 fulfilled 状态，还是变为 rejected 状态 )，p 的回调函数的参数，是最先改变状态的那个 promise 实例的返回值 传入的参数是不可迭代的，将会抛出错误。 传的参数数组是空，返回的 promise 将永远等待。 实现一个 Promise.race 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Promise.race = function(promiseObj) &#123; //promises 必须是一个可遍历的数据结构，否则抛错 return new Promise((resolve, reject) =&gt; &#123; //判断当前的promiseObj是否可迭代 if (typeof promiseObj[Symbol.iterator] !== 'function') &#123; Promise.reject('args is not iteratable!') &#125; if (promiseObj.length === 0) &#123; return &#125; else &#123; for (let i = 0, l = promiseObj.length; i &lt; l; i++) &#123; Promise.resolve(promiseObj[i]).then( data =&gt; &#123; resolve(data) return &#125;, err =&gt; &#123; reject(err) return &#125; ) &#125; &#125; &#125;)&#125;//测试//一直在等待态Promise.race([]).then( data =&gt; &#123; console.log('success ', data) &#125;, err =&gt; &#123; console.log('err ', err) &#125;)//抛错Promise.race().then( data =&gt; &#123; console.log('success ', data) &#125;, err =&gt; &#123; console.log('err ', err) &#125;)Promise.race([ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 1000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2) &#125;, 200) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(3) &#125;, 300) &#125;)]).then( data =&gt; &#123; console.log(data) &#125;, err =&gt; &#123; console.log(err) &#125;) Promise.resolve() promise.resolve()可以将对象转换为 promise 对象 promise.resolve(‘foo’) 等价于 new Promise(resolve =&gt; resolve(&#39;foo&#39;)) Promise.resolve() 参数示例： 参数为 promise 实例对象，Promise.resolve()方法将原封不动的( 返回这个实例对象 ) 123456const foo = new Promise((resolve, reject) =&gt; &#123; return resolve('promise实例对象')&#125;)const p = Promise.resolve(foo)console.log(p)// 输出： Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: "foo是一个promise实例对象"&#125; 参数为 thenable 对象，Promise.resolve()方法会将这个对象转化为 promise 对象，然后立刻执行 thenable 对象的 then 方法 123456789什么是 thenable 对象 ？let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;Promise.resolve(thenable) // 参数是thenable对象，立刻执行thenable对象的then方法 .then(res =&gt; console.log(res)) // thenable对象的的状态是fulfilled，输出其返回值 参数不是 thenable 对象，或者根本不是一个对象，参数是一个原始类型的值( 数字，字符串，布尔值 )，或者是一个不具有 then 方法的对象，则 Promise.resolve()方法返回一个新的 promise 对象，状态是 fulfilled 12345const str = 'abc'const foo = Promise.resolve(str)// 参数是原始类型的值，Promise.resolve()方法会返回一个promise对象，状态是resolvedfoo.then(res =&gt; console.log(res)) // 所以该回调会执行 不带参数,直接返回一个 promise 对象，状态是 resolved; Promise.reject()方法 Promise.reject()方法返回一个 promise 实例对象，状态是 rejected 和 Promise.resolve()类似，只是 Promise.rejected()方法的状态一定是 rejected 123456789101112const p = Promise.reject('出错了')p.then(null, function(s) &#123; console.log(s)&#125;)// 出错了// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function(s) &#123; console.log(s)&#125;)// 出错了 ####]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise 到 Generator 再到 Async / Await]]></title>
    <url>%2F2019%2F08%2F23%2Fpromise%2F</url>
    <content type="text"><![CDATA[1. js 异步处理的异步最早的解决方案是回调函数，如事件的回调，setInterval/setTimeout 中的回调。但是回到函数有一个很常见的问题，回调地狱。 为了解决回调地狱问题，社区提出了 promise 解决方案，es6 将其写进了语言标准，promise 解决了回调地狱问题，但是 promise 也存在一些问题，如错误能被 try catch，而且使用 promise 的链式调用，其实没有从根本上解决回调地狱的问题，只是换了一种写法。 es6 中引入了 Generator 函数，Generator 是一种异步编程解决方案，Generator 函数是协程在 es6 的实现，最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语句注明，但是 Genrator 使用起来比较复杂。 es7 又提出了新的一步解决方案：async / await, async 是 Generator 的函数语法糖，async/await 使得异步代码看起来像同步，异步编程发展的目标就是让异步逻辑的代码看起来像同步一样。 回调函数： callback 123//node读取文件fs.readFile(xx,'utf-8',function(err. data) &#123;&#125;) 回调函数的使用场景（包括但不限于）： 事件回调 Node API setTimeout 、setInterval 中的回调函数 异步回调嵌套会导致代码难以维护，并且不方便统一处理错误，不能 try catch 和回调地狱（如读取 A 文本的类容，再根据 A 文本内容读取 B 文本，再根据 B 文本内容读取 C..) 回调地狱： 1234567fs.readFile(A, 'utf-8', function() &#123; fs.readFile(B, 'utf-8', function() &#123; fs.readFile(C, 'utf-8', function() &#123; //... &#125;) &#125;)&#125;) 2. Promisepromise 主要解决回调地狱的问题，promise 最早由社区提出和实现，es6 将其写进语言标准，统一用法，原生提供 Promise 对象； Promise 解决回调地狱问题： 12345678910111213141516171819function read(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url, 'utf-8', (err, data) =&gt; &#123; if (err) reject(data) resolve(data) &#125;) &#125;)&#125;read(A) .then(data =&gt; &#123; return read(B) &#125;) .then(data =&gt; &#123; return read(C) &#125;) .catch(reason =&gt; &#123; console.log(reason) &#125;) 思考： 在 Promise之前，你是如何处理异步并发问题的，假设有这样一个需求：读取三个文件内容，都读取成功后，输出最终的结果。有了 Promise 之后，又如何处理呢？示例 3. GeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案，整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。 Generator 函数一般配合 yield 或 Promise 使用。Generator 函数返回的是迭代器。 123456789101112131415161718function* gen() &#123; let a = yield 11 console.log(a) let b = yield 22 console.log(b) let c = yield 33 console.log(c) let d = yield 44 console.log(d)&#125;let t = gen()//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值//next 调用后返回一个对象&#123;value: yield 后面的值, done: false&#125;t.next(1) //第一次调用next函数时，传递的参数无效 返回&#123;value:11,done:false&#125;t.next(2) //a输出2; 返回&#123;value:22,done:false&#125;t.next(3) //b输出3;t.next(4) //c输出4;t.next(5) //d输出5; 返回&#123;value: undefined, done: true&#125; 4. Async / Awaitasync 关键字，定义的函数是异步函数，返回 promise 对象 await 操作符用于等待一个 Promise 对象, 只能在异步函数 async function 内部使用. 123456789const fun1 = () =&gt; console.log('叭叭叭1')const fun2 = () =&gt; console.log('叭叭叭2')const fun = async () =&gt; &#123; // async关键字，定义的函数是异步函数，返回promise对象 await fun1()&#125;fun().then(fun2())console.log('叭叭叭') async/await 的实现原理 async/await 就是 Generator 的语法糖，就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await。 async 函数内置执行器，函数调用之后，会自动执行(Generator 需要手动调用函数 next())，输出最后结果。 更好的语义化，async 和 await，对比星号和 yield。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值。 返回值是 Promise，async 函数的返回值是 Promise 对象在，Generator 的返回值是 Iterator，Promise 对象使用起来更加方便。 async 函数的实现原理，将 Generator 函数和自动执行器，包装在函数里示例 使用 async/await 需要注意什么 await 命令后面的Promise对象，运行结果可能是 rejected，此时等同于 async 函数返回的 Promise 对象被reject。因此需要加上错误处理，可以给每个 await 后的 Promise 增加 catch 方法；也可以将 await 的代码放在 try...catch 中。 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 123456789101112131415161718192021222324//下面两种写法都可以同时触发//法一async function f1() &#123; await Promise.all([ new Promise((resolve) =&gt; &#123; setTimeout(resolve, 600); &#125;), new Promise((resolve) =&gt; &#123; setTimeout(resolve, 600); &#125;) ])&#125;//法二async function f2() &#123; let fn1 = new Promise((resolve) =&gt; &#123; setTimeout(resolve, 800); &#125;); let fn2 = new Promise((resolve) =&gt; &#123; setTimeout(resolve, 800); &#125;) await fn1; await fn2;&#125; await命令只能用在async函数之中，如果用在普通函数，会报错。 async 函数可以保留运行堆栈。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** 函数a内部执行异步任务b()。当b()执行的时候，函数a()不会中断，而是继续执行。* 等到b()执行结束，可能a()已执行结束，b()所在的上下文环境已经消失了。* 如果b()或c()报错，错误堆栈将不包括a()。*/function b() &#123; return new Promise((resolve, reject) =&gt; &#123; console.log('b中的输出') setTimeout((resolve)=&gt; &#123; resolve('b-promise实例') &#125;, 200,resolve) &#125;);&#125;function c() &#123; console.log('c中的输出') throw Error(10);&#125;const a = () =&gt; &#123; //异步任务b b().then((data) =&gt; &#123; console.log(data); c() &#125;); //同步输出 console.log('a中同步输出') //没有返回默认返回 undefined; return 'a执行结束'&#125;;a();/** b中的输出 a中同步输出 "a执行结束" a()执行结束的返回 b-promise实例 c中的输出 Uncaught (in promise) Error: 10*//*** 改成async函数*/const m = async () =&gt; &#123; var b_result=await b(); console.log(b_result) c();&#125;;m();/*b中的输出Promise &#123;&lt;pending&gt;&#125; a()执行结束的返回(async 后的函数执行返回一个promise对象)b-promise实例c中的输出*/]]></content>
      <categories>
        <category>前端</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
